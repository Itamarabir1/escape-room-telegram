# ארכיטקטורת מצב משחק ומשימות

## איפה נתוני המשימות והתשובות?

- **תוכן משימות (טקסט, רמז, תשובה נכונה):** בבאקאנד בלבד – לא נשלח ללקוח.
- **מצב משחק נוכחי (איזה חדר, אילו פריטים, אילו חידות):** Redis (game state). כל קריאת `GET /api/games/{game_id}` ו־`POST /api/games/{game_id}/action` משתמשת ב־Redis.
- **אימות תשובות:** תמיד בשרת. הפרונט שולח תשובה ל־POST `/action`; הבאקאנד משווה ל־`correct_answer` שנשמר ב־Redis (ממקור המשימה). אין אימות בצד הלקוח.

## Redis vs Postgres

| שימוש | איפה | למה |
|------|------|-----|
| מצב משחק פעיל (room_items, room_puzzles, players) | **Redis** | מהיר, TTL, מתאים ל־session; משחק "חי" למשך זמן מוגבל. |
| הגדרות משימות (תוכן, תשובות נכונות) | **קוד / לוגיקה** (כרגע: `data/demo_room.py` או AI) | בדמו – מקור אחד בשרת. בעתיד ניתן להעביר ל־Postgres (טבלת tasks) לעריכה בלי deploy. |
| נתונים קבועים / היסטוריה (משחקים שהסתיימו, סטטיסטיקות) | **Postgres** (אופציונלי) | אם תרצה לשמור סיכומים או דוחות – Postgres מתאים. |

## זרימת תשובה

1. משתמש מזין תשובה במודל (פרונט).
2. פרונט שולח `POST /api/games/{game_id}/action` עם `{ item_id, answer }`.
3. באקאנד: טוען game מ־Redis, מחפש `room_puzzles[item_id]`, משווה `answer` ל־`correct_answer` (נורמליזציה).
4. באקאנד מחזיר `{ correct, message }` – הפרונט מציג הצלחה/כישלון.

התשובה הנכונה לא נשלחת ל־client; ההשוואה מתבצעת רק בשרת.
